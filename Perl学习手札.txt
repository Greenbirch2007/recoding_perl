
CGI

就是所谓的“Common Gateway Interface”，动态网站程序的设计界面。

标量变量 Scalar $

\a：会发出哔的警铃声
\d：代表一个数字的字符
\D：代表一个非数字的字符
\e：跳脱符号 (escape)
\f：换页
\n：换行
\s：一个空白字符 (包括空行，换页，跳格键也都属于空白字符)
\S：非空白字符
\t：跳格字符 (Tab)
\w：一个字母，包括了a-z，A-Z，底线跟数字
\W：非字母


3. 列表与数组

$#array是数组中最后一个索引值
所以我们可以利用($#array + 1)得到目前数组中的元素个数(注二)。不过如果你打算利用这个索引值来确定目前数组的长度，并且加入新的元素，就像这样：

push,pop  最后元素，加，减

shift,unshift 最前面元素，减，加
切片



数组还是标量？
利用列表赋值给数组
在标量语境中记性
先以标量语境进行运算，然后以列表方式给数组

my @array = (1...10);   # 利用列表赋值给数组
my $scalar = @array + 4;   # 在标量语境中进行
my @scalar_array = @array + 4;  
# 先以标量语境进行运算，然后以列表方式赋值给数组

3.7 一些常用的数组运算
@_
sort($a,$b,<=>,cmp)
join,split
map,grep

排序前的数组4 6 9 61 3 64
b的数组4 6 9 61 3 64
排序后的数组3 4 6 9 61 64
排序后的b 4 6 9 61 3 64

所以perl里面的数组也是值类型，跟golang一样。但切片?
切片好像也是值类型

整数排序
其中$a跟$b是Perl的默认变量，在排序时被拿来作为两两取出的两个数字。而<=>则是表示数字的比较，如果数组中的元素是字符串，则必须以cmp来进行排序。
我们可以用接下来的例子来说明怎么样进行更复杂的排序工作。
sort {$a <=>$b} 低到高
sort {$b <=>$a}  高到低
字符串排序
cmp

sort 
sort {$a <=>$b} 低到高
sort {$b <=>$a}  高到低
@array = sort { $a cmp $b} @array;
@array = sort { $b cmp $a} @array;


my @array = qw/-4 45 -33 8 75 21 -15 38 -69 46/;
@array = sort { ($a**2) <=> ($b**2) } @array;   # 这次我们以平方进行排序
所以得到的结果会是：
-4 8 -15 21 -33 38 45 46 -69 75

join 列表中元素拼接为一个字符串

split 一个字符串分割，并放入数组

print join',',qw /s s s /;
print split',',"it's , saf";

3. map 将数组表里面的元素意义提出，运算，然后等到一个列表，放入数组
类似于python的lambda

my @array = map { sqrt($_)*10 } qw/45 33 8 75 21 15 38 69 46/;
print  "@array \n";

4.grep  可以把列表中匹配的元素留下来

my @array  =qw / 1 6 -2 5 1 -8 /;

my @grep_n = grep {$_>0} @array;

print "$_\n" for @grep_n;
$_ .= "\n" for @a;
map $_."\n", @a;

my map_ar = map s_*10,  @sites;

一、 将数字列表转换为相应的字符列表

my @chars = map(chr,@numbers);
二、 对数字列表中的每个元素计算平方，返回平方值的列表

my @quares = map {$_ * $_ } @numbers;
三、返回满足条件的数字的列表

my @numbers = map { $_ > 5 ? $_ : ()} @numbers;
注意
在BLOCK中$_ 是列表元素的别名，因为可以修改原列表的中元素的值。
如果列表中的元素不是变量，而在BLOCK中修改了$_的值，将会产生不可预料的结果。


my @sites =  (24, 33, 65, 42, 58, 24, 87);
# print @sites;
# print "$sites[0]\n";
my @new_ar = sort {$a <=> $b} @sites;
# print @new_ar;
# print $_ "\n" for @new_ar;

my @grep_ar = grep {$_ >40} @sites;
# print @grep_ar;

my @map_ar = map {$_*11}  @sites;
print @map_ar;



#!/usr/bin/perl
use strict;
my ($sum,$i);
while ($i < 100) {
$sum+=$i;
$i++;

}
print $sum;


4. 基本的控制结构

comminuty

4.1.3 区块 BLOCK
4.1.4 变量的生命周期


my $a = 3;
my $b = 9;

{
    print "$a \n"; # 属于外层的区块，所以你会看到3
    my $b =6; # 定了这个区块内自己的变量
    print "$b \n"; # 于是 输出6
}

{
   print "$a \n"; # 属于外层的区块，所以你会看到3
   print "$b \n"; # 于是 输出9
}

   print "$a \n"; # 属于外层的区块，所以你会看到3
   print "$b \n"; # 于是 输出9
   
 
 
 unless -----!if
 
 if (!($a<3)) 等价于unless($a<3)
 
 等价的写法
 
 if ($num<5){
	$num++;
	}
	
$num++ if ($num<5);

if ($num ==1){...}
if ($num !=1){...}



if ($num ==1){
...
}else{
}


if ($date eq 'm'){
...
}elsif ($date eq 't')
}else{
	print ""
	}
	
4.3 重复执行


4.3.1 while

单一判断可以使用倒装句，

while (1){
	print "这是无限循环";
	}
print "这是无限循环" while(1);

4.3.2 until

while <--->untll

unil ()

my $num = 1;
my $result = 1;
until ($num>10) {
    $result*=$num;
    $num+=1;
    print "$result $num \n";
}

4.4 for循环

my $result = 1;
for (my $num=1;$num <=10;$num+=1){
    $result *= $num;
}

可以非常件韩

for my $num (1..10){
print $num;
}

for (1..10){
print $_;
}

print for {1..10};


print foreach (@array);
foreach my $element (@array)

习题：

1. 算出1+3+5+...+99的值

2. 如果我们从1加到n，那么在累加结果不超过100，n的最大值应该是多少？
3. 让使用者输入一个数字，如果输入的数字小于50，则算出他的阶乘，否则就印出数字太大的警告。

	#!/usr/bin/perl


chomp(my $input =<STDIN>);
if ($input<50){
    my $total = 1;
    for ($i=1; $i<=$input; $i++) {
        $total *= $i;
        
    }
    print $total;

}else{
    print "too big";
}
